// UI Components - Reusable UI elements and utilities\nconst UI = {\n    \n    // Toast notification system\n    Toast: {\n        container: null,\n        queue: [],\n        isProcessing: false,\n\n        init() {\n            if (!this.container) {\n                this.container = document.createElement(\'div\');\n                this.container.className = \'toast-container\';\n                this.container.style.cssText = `\n                    position: fixed;\n                    top: 1rem;\n                    right: 1rem;\n                    z-index: ${CSS.escape(\'var(--z-toast)\')};\n                    display: flex;\n                    flex-direction: column;\n                    gap: 0.5rem;\n                    pointer-events: none;\n                `;\n                document.body.appendChild(this.container);\n            }\n        },\n\n        show(message, type = \'info\', options = {}) {\n            this.init();\n            \n            const {\n                duration = Config.APP.TOAST_DURATION,\n                actions = [],\n                dismissible = true,\n                position = \'top-right\'\n            } = options;\n\n            const toast = {\n                id: Utils.generateId(\'toast\'),\n                message,\n                type,\n                duration,\n                actions,\n                dismissible,\n                position\n            };\n\n            this.queue.push(toast);\n            this.processQueue();\n        },\n\n        async processQueue() {\n            if (this.isProcessing || this.queue.length === 0) return;\n            \n            this.isProcessing = true;\n            const toast = this.queue.shift();\n            \n            await this.renderToast(toast);\n            \n            this.isProcessing = false;\n            \n            // Process next toast\n            if (this.queue.length > 0) {\n                setTimeout(() => this.processQueue(), 300);\n            }\n        },\n\n        async renderToast(toast) {\n            const toastElement = document.createElement(\'div\');\n            toastElement.className = `toast ${toast.type}`;\n            toastElement.id = toast.id;\n            toastElement.style.cssText = `\n                pointer-events: auto;\n                transform: translateX(100%);\n                transition: transform 0.3s ease;\n            `;\n\n            const icon = this.getTypeIcon(toast.type);\n            \n            toastElement.innerHTML = `\n                <div class=\"toast-content\">\n                    <i class=\"fas fa-${icon} toast-icon\"></i>\n                    <span class=\"toast-message\">${Utils.sanitizeHtml(toast.message)}</span>\n                    ${toast.dismissible ? \'<button class=\"toast-close\" onclick=\"UI.Toast.dismiss(\\\'\' + toast.id + \'\\\')\"><i class=\"fas fa-times\"></i></button>\' : \'\'}\n                </div>\n                ${toast.actions.length > 0 ? this.renderActions(toast.actions) : \'\'}\n            `;\n\n            this.container.appendChild(toastElement);\n\n            // Animate in\n            requestAnimationFrame(() => {\n                toastElement.style.transform = \'translateX(0)\';\n            });\n\n            // Auto dismiss\n            if (toast.duration > 0) {\n                setTimeout(() => {\n                    this.dismiss(toast.id);\n                }, toast.duration);\n            }\n        },\n\n        renderActions(actions) {\n            const actionsHtml = actions.map(action => \n                `<button class=\"toast-action\" onclick=\"${action.onClick}\">${action.label}</button>`\n            ).join(\'\');\n            \n            return `<div class=\"toast-actions\">${actionsHtml}</div>`;\n        },\n\n        getTypeIcon(type) {\n            const icons = {\n                success: \'check-circle\',\n                error: \'exclamation-circle\',\n                warning: \'exclamation-triangle\',\n                info: \'info-circle\'\n            };\n            return icons[type] || icons.info;\n        },\n\n        dismiss(toastId) {\n            const toastElement = document.getElementById(toastId);\n            if (toastElement) {\n                toastElement.style.transform = \'translateX(100%)\';\n                setTimeout(() => {\n                    toastElement.remove();\n                }, 300);\n            }\n        },\n\n        dismissAll() {\n            const toasts = this.container.querySelectorAll(\'.toast\');\n            toasts.forEach(toast => {\n                this.dismiss(toast.id);\n            });\n        },\n\n        // Convenience methods\n        success(message, options = {}) {\n            this.show(message, \'success\', options);\n        },\n\n        error(message, options = {}) {\n            this.show(message, \'error\', options);\n        },\n\n        warning(message, options = {}) {\n            this.show(message, \'warning\', options);\n        },\n\n        info(message, options = {}) {\n            this.show(message, \'info\', options);\n        }\n    },\n\n    // Loading overlay system\n    Loading: {\n        overlay: null,\n        isVisible: false,\n\n        show(message = \'Yuklanmoqda...\', options = {}) {\n            const { \n                backdrop = true, \n                spinner = true,\n                cancellable = false,\n                onCancel = null \n            } = options;\n\n            if (this.isVisible) {\n                this.updateMessage(message);\n                return;\n            }\n\n            this.overlay = document.createElement(\'div\');\n            this.overlay.id = \'loadingOverlay\';\n            this.overlay.className = \'loading-overlay\';\n            this.overlay.style.cssText = `\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background: ${backdrop ? \'rgba(0, 0, 0, 0.5)\' : \'transparent\'};\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                z-index: var(--z-modal);\n                backdrop-filter: blur(2px);\n            `;\n\n            const content = document.createElement(\'div\');\n            content.className = \'loading-content\';\n            content.style.cssText = `\n                background: white;\n                padding: 2rem;\n                border-radius: 12px;\n                text-align: center;\n                box-shadow: var(--shadow-lg);\n                max-width: 300px;\n            `;\n\n            content.innerHTML = `\n                ${spinner ? \'<div class=\"spinner\" style=\"margin: 0 auto 1rem;\"></div>\' : \'\'}\n                <div class=\"loading-message\" style=\"color: var(--gray-800); font-weight: 600;\">${Utils.sanitizeHtml(message)}</div>\n                ${cancellable ? \'<button class=\"btn btn-outline btn-sm\" style=\"margin-top: 1rem;\" onclick=\"UI.Loading.cancel()\">Bekor qilish</button>\' : \'\'}\n            `;\n\n            this.overlay.appendChild(content);\n            document.body.appendChild(this.overlay);\n\n            if (cancellable && onCancel) {\n                this.onCancel = onCancel;\n            }\n\n            // Prevent scrolling\n            document.body.style.overflow = \'hidden\';\n            this.isVisible = true;\n\n            // Animate in\n            requestAnimationFrame(() => {\n                this.overlay.style.opacity = \'1\';\n            });\n        },\n\n        updateMessage(message) {\n            if (this.overlay) {\n                const messageElement = this.overlay.querySelector(\'.loading-message\');\n                if (messageElement) {\n                    messageElement.textContent = message;\n                }\n            }\n        },\n\n        hide() {\n            if (this.overlay && this.isVisible) {\n                this.overlay.style.opacity = \'0\';\n                setTimeout(() => {\n                    if (this.overlay && this.overlay.parentNode) {\n                        this.overlay.parentNode.removeChild(this.overlay);\n                    }\n                    this.overlay = null;\n                    this.isVisible = false;\n                    document.body.style.overflow = \'\';\n                }, 300);\n            }\n        },\n\n        cancel() {\n            if (this.onCancel) {\n                this.onCancel();\n            }\n            this.hide();\n        }\n    },\n\n    // Modal system\n    Modal: {\n        activeModals: new Set(),\n\n        show(modalId) {\n            const modal = document.getElementById(modalId);\n            if (modal) {\n                modal.classList.add(\'active\');\n                this.activeModals.add(modalId);\n                document.body.style.overflow = \'hidden\';\n                \n                // Focus management\n                this.trapFocus(modal);\n                \n                // Add backdrop click listener\n                modal.addEventListener(\'click\', this.handleBackdropClick.bind(this));\n            }\n        },\n\n        hide(modalId) {\n            const modal = document.getElementById(modalId);\n            if (modal) {\n                modal.classList.remove(\'active\');\n                this.activeModals.delete(modalId);\n                \n                if (this.activeModals.size === 0) {\n                    document.body.style.overflow = \'\';\n                }\n                \n                modal.removeEventListener(\'click\', this.handleBackdropClick.bind(this));\n            }\n        },\n\n        hideAll() {\n            this.activeModals.forEach(modalId => {\n                this.hide(modalId);\n            });\n        },\n\n        handleBackdropClick(event) {\n            if (event.target.classList.contains(\'modal\')) {\n                this.hide(event.target.id);\n            }\n        },\n\n        trapFocus(modal) {\n            const focusableElements = modal.querySelectorAll(\n                \'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])\'\n            );\n            \n            const firstElement = focusableElements[0];\n            const lastElement = focusableElements[focusableElements.length - 1];\n\n            modal.addEventListener(\'keydown\', (e) => {\n                if (e.key === \'Tab\') {\n                    if (e.shiftKey) {\n                        if (document.activeElement === firstElement) {\n                            lastElement.focus();\n                            e.preventDefault();\n                        }\n                    } else {\n                        if (document.activeElement === lastElement) {\n                            firstElement.focus();\n                            e.preventDefault();\n                        }\n                    }\n                }\n                \n                if (e.key === \'Escape\') {\n                    this.hide(modal.id);\n                }\n            });\n\n            if (firstElement) {\n                firstElement.focus();\n            }\n        }\n    },\n\n    // Progress bar component\n    ProgressBar: {\n        create(options = {}) {\n            const {\n                value = 0,\n                max = 100,\n                showLabel = true,\n                animated = true,\n                color = \'var(--primary-color)\',\n                height = \'8px\'\n            } = options;\n\n            const container = document.createElement(\'div\');\n            container.className = \'progress-bar-container\';\n            container.style.cssText = `\n                width: 100%;\n                background: var(--gray-200);\n                border-radius: ${height};\n                overflow: hidden;\n                position: relative;\n            `;\n\n            const bar = document.createElement(\'div\');\n            bar.className = \'progress-bar\';\n            bar.style.cssText = `\n                height: ${height};\n                background: ${color};\n                width: ${(value / max) * 100}%;\n                transition: ${animated ? \'width 0.3s ease\' : \'none\'};\n                border-radius: ${height};\n            `;\n\n            const label = document.createElement(\'div\');\n            label.className = \'progress-label\';\n            label.style.cssText = `\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                font-size: 12px;\n                font-weight: bold;\n                color: var(--gray-700);\n                display: ${showLabel ? \'block\' : \'none\'};\n            `;\n            label.textContent = `${Math.round((value / max) * 100)}%`;\n\n            container.appendChild(bar);\n            container.appendChild(label);\n\n            return {\n                element: container,\n                update: (newValue) => {\n                    const percentage = Math.min(Math.max((newValue / max) * 100, 0), 100);\n                    bar.style.width = `${percentage}%`;\n                    if (showLabel) {\n                        label.textContent = `${Math.round(percentage)}%`;\n                    }\n                },\n                setValue: (newValue) => {\n                    return this.update(newValue);\n                },\n                setColor: (newColor) => {\n                    bar.style.background = newColor;\n                }\n            };\n        }\n    },\n\n    // Skeleton loader component\n    Skeleton: {\n        create(options = {}) {\n            const {\n                width = \'100%\',\n                height = \'20px\',\n                borderRadius = \'4px\',\n                lines = 1,\n                gap = \'8px\'\n            } = options;\n\n            const container = document.createElement(\'div\');\n            container.className = \'skeleton-container\';\n            container.style.cssText = `\n                display: flex;\n                flex-direction: column;\n                gap: ${gap};\n            `;\n\n            for (let i = 0; i < lines; i++) {\n                const skeleton = document.createElement(\'div\');\n                skeleton.className = \'skeleton\';\n                skeleton.style.cssText = `\n                    width: ${Array.isArray(width) ? width[i] || width[0] : width};\n                    height: ${height};\n                    border-radius: ${borderRadius};\n                `;\n                container.appendChild(skeleton);\n            }\n\n            return container;\n        },\n\n        createCard() {\n            return this.create({\n                lines: 4,\n                width: [\'100%\', \'80%\', \'60%\', \'90%\'],\n                height: \'16px\',\n                gap: \'12px\'\n            });\n        },\n\n        createList(items = 3) {\n            const container = document.createElement(\'div\');\n            container.style.cssText = \'display: flex; flex-direction: column; gap: 16px;\';\n\n            for (let i = 0; i < items; i++) {\n                const item = this.create({\n                    lines: 2,\n                    width: [\'100%\', \'70%\'],\n                    height: \'14px\'\n                });\n                container.appendChild(item);\n            }\n\n            return container;\n        }\n    },\n\n    // Dropdown component\n    Dropdown: {\n        activeDropdown: null,\n\n        init(triggerSelector, dropdownSelector, options = {}) {\n            const trigger = document.querySelector(triggerSelector);\n            const dropdown = document.querySelector(dropdownSelector);\n            \n            if (!trigger || !dropdown) return;\n\n            const {\n                placement = \'bottom-start\',\n                closeOnClick = true,\n                closeOnOutsideClick = true\n            } = options;\n\n            trigger.addEventListener(\'click\', (e) => {\n                e.stopPropagation();\n                this.toggle(dropdown, trigger, placement);\n            });\n\n            if (closeOnClick) {\n                dropdown.addEventListener(\'click\', (e) => {\n                    if (e.target.tagName === \'A\' || e.target.closest(\'a\')) {\n                        this.hide(dropdown);\n                    }\n                });\n            }\n\n            if (closeOnOutsideClick) {\n                document.addEventListener(\'click\', (e) => {\n                    if (!trigger.contains(e.target) && !dropdown.contains(e.target)) {\n                        this.hide(dropdown);\n                    }\n                });\n            }\n        },\n\n        toggle(dropdown, trigger, placement) {\n            if (this.activeDropdown === dropdown) {\n                this.hide(dropdown);\n            } else {\n                this.show(dropdown, trigger, placement);\n            }\n        },\n\n        show(dropdown, trigger, placement) {\n            this.hideAll();\n            \n            dropdown.style.display = \'block\';\n            this.position(dropdown, trigger, placement);\n            \n            requestAnimationFrame(() => {\n                dropdown.classList.add(\'show\');\n            });\n\n            this.activeDropdown = dropdown;\n        },\n\n        hide(dropdown) {\n            dropdown.classList.remove(\'show\');\n            setTimeout(() => {\n                dropdown.style.display = \'none\';\n                if (this.activeDropdown === dropdown) {\n                    this.activeDropdown = null;\n                }\n            }, 150);\n        },\n\n        hideAll() {\n            if (this.activeDropdown) {\n                this.hide(this.activeDropdown);\n            }\n        },\n\n        position(dropdown, trigger, placement) {\n            const triggerRect = trigger.getBoundingClientRect();\n            const dropdownRect = dropdown.getBoundingClientRect();\n            \n            let top, left;\n\n            switch (placement) {\n                case \'bottom-start\':\n                    top = triggerRect.bottom + window.scrollY;\n                    left = triggerRect.left + window.scrollX;\n                    break;\n                case \'bottom-end\':\n                    top = triggerRect.bottom + window.scrollY;\n                    left = triggerRect.right + window.scrollX - dropdownRect.width;\n                    break;\n                case \'top-start\':\n                    top = triggerRect.top + window.scrollY - dropdownRect.height;\n                    left = triggerRect.left + window.scrollX;\n                    break;\n                case \'top-end\':\n                    top = triggerRect.top + window.scrollY - dropdownRect.height;\n                    left = triggerRect.right + window.scrollX - dropdownRect.width;\n                    break;\n                default:\n                    top = triggerRect.bottom + window.scrollY;\n                    left = triggerRect.left + window.scrollX;\n            }\n\n            dropdown.style.position = \'absolute\';\n            dropdown.style.top = `${top}px`;\n            dropdown.style.left = `${left}px`;\n            dropdown.style.zIndex = \'var(--z-dropdown)\';\n        }\n    },\n\n    // Pagination component\n    Pagination: {\n        create(options = {}) {\n            const {\n                currentPage = 1,\n                totalPages = 1,\n                onPageChange = () => {},\n                showFirstLast = true,\n                showPrevNext = true,\n                maxVisiblePages = 5\n            } = options;\n\n            const container = document.createElement(\'div\');\n            container.className = \'pagination\';\n            container.style.cssText = `\n                display: flex;\n                align-items: center;\n                gap: 0.5rem;\n                justify-content: center;\n                flex-wrap: wrap;\n            `;\n\n            // First page button\n            if (showFirstLast && currentPage > 1) {\n                const firstBtn = this.createButton(\'1\', () => onPageChange(1));\n                container.appendChild(firstBtn);\n                \n                if (currentPage > maxVisiblePages) {\n                    container.appendChild(this.createEllipsis());\n                }\n            }\n\n            // Previous button\n            if (showPrevNext && currentPage > 1) {\n                const prevBtn = this.createButton(\'‹\', () => onPageChange(currentPage - 1), \'prev\');\n                container.appendChild(prevBtn);\n            }\n\n            // Page numbers\n            const startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));\n            const endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);\n\n            for (let i = startPage; i <= endPage; i++) {\n                const pageBtn = this.createButton(\n                    i.toString(), \n                    () => onPageChange(i), \n                    i === currentPage ? \'active\' : \'\'\n                );\n                container.appendChild(pageBtn);\n            }\n\n            // Next button\n            if (showPrevNext && currentPage < totalPages) {\n                const nextBtn = this.createButton(\'›\', () => onPageChange(currentPage + 1), \'next\');\n                container.appendChild(nextBtn);\n            }\n\n            // Last page button\n            if (showFirstLast && currentPage < totalPages) {\n                if (currentPage < totalPages - maxVisiblePages + 1) {\n                    container.appendChild(this.createEllipsis());\n                }\n                \n                const lastBtn = this.createButton(totalPages.toString(), () => onPageChange(totalPages));\n                container.appendChild(lastBtn);\n            }\n\n            return container;\n        },\n\n        createButton(text, onClick, className = \'\') {\n            const button = document.createElement(\'button\');\n            button.className = `pagination-btn ${className}`;\n            button.textContent = text;\n            button.style.cssText = `\n                padding: 0.5rem 0.75rem;\n                border: 1px solid var(--gray-300);\n                background: var(--white);\n                color: var(--gray-700);\n                border-radius: var(--radius);\n                cursor: pointer;\n                transition: var(--transition-normal);\n                min-width: 40px;\n            `;\n\n            if (className === \'active\') {\n                button.style.background = \'var(--primary-color)\';\n                button.style.color = \'var(--white)\';\n                button.style.borderColor = \'var(--primary-color)\';\n            }\n\n            button.addEventListener(\'click\', onClick);\n            \n            button.addEventListener(\'mouseenter\', () => {\n                if (className !== \'active\') {\n                    button.style.background = \'var(--gray-50)\';\n                }\n            });\n\n            button.addEventListener(\'mouseleave\', () => {\n                if (className !== \'active\') {\n                    button.style.background = \'var(--white)\';\n                }\n            });\n\n            return button;\n        },\n\n        createEllipsis() {\n            const span = document.createElement(\'span\');\n            span.textContent = \'...\';\n            span.style.cssText = `\n                padding: 0.5rem 0.25rem;\n                color: var(--gray-500);\n            `;\n            return span;\n        }\n    },\n\n    // Tabs component\n    Tabs: {\n        init(containerSelector, options = {}) {\n            const container = document.querySelector(containerSelector);\n            if (!container) return;\n\n            const {\n                activeClass = \'active\',\n                onChange = () => {}\n            } = options;\n\n            const tabs = container.querySelectorAll(\'[data-tab]\');\n            const panels = container.querySelectorAll(\'[data-panel]\');\n\n            tabs.forEach(tab => {\n                tab.addEventListener(\'click\', (e) => {\n                    e.preventDefault();\n                    \n                    const targetPanel = tab.dataset.tab;\n                    \n                    // Remove active class from all tabs and panels\n                    tabs.forEach(t => t.classList.remove(activeClass));\n                    panels.forEach(p => p.classList.remove(activeClass));\n                    \n                    // Add active class to clicked tab and corresponding panel\n                    tab.classList.add(activeClass);\n                    const panel = container.querySelector(`[data-panel=\"${targetPanel}\"]`);\n                    if (panel) {\n                        panel.classList.add(activeClass);\n                    }\n                    \n                    onChange(targetPanel, tab, panel);\n                });\n            });\n        }\n    },\n\n    // Accordion component\n    Accordion: {\n        init(containerSelector, options = {}) {\n            const container = document.querySelector(containerSelector);\n            if (!container) return;\n\n            const {\n                allowMultiple = false,\n                activeClass = \'active\'\n            } = options;\n\n            const triggers = container.querySelectorAll(\'[data-accordion-trigger]\');\n\n            triggers.forEach(trigger => {\n                trigger.addEventListener(\'click\', () => {\n                    const target = trigger.getAttribute(\'data-accordion-trigger\');\n                    const panel = container.querySelector(`[data-accordion-panel=\"${target}\"]`);\n                    \n                    if (!panel) return;\n\n                    const isActive = trigger.classList.contains(activeClass);\n\n                    if (!allowMultiple) {\n                        // Close all other panels\n                        triggers.forEach(t => t.classList.remove(activeClass));\n                        container.querySelectorAll(\'[data-accordion-panel]\')\n                            .forEach(p => p.classList.remove(activeClass));\n                    }\n\n                    if (!isActive) {\n                        trigger.classList.add(activeClass);\n                        panel.classList.add(activeClass);\n                    } else if (allowMultiple) {\n                        trigger.classList.remove(activeClass);\n                        panel.classList.remove(activeClass);\n                    }\n                });\n            });\n        }\n    },\n\n    // Image lazy loading\n    LazyLoad: {\n        observer: null,\n\n        init(selector = \'img[data-src]\', options = {}) {\n            const {\n                rootMargin = \'50px\',\n                threshold = 0.1\n            } = options;\n\n            if (\'IntersectionObserver\' in window) {\n                this.observer = new IntersectionObserver((entries) => {\n                    entries.forEach(entry => {\n                        if (entry.isIntersecting) {\n                            this.loadImage(entry.target);\n                            this.observer.unobserve(entry.target);\n                        }\n                    });\n                }, { rootMargin, threshold });\n\n                document.querySelectorAll(selector).forEach(img => {\n                    this.observer.observe(img);\n                });\n            } else {\n                // Fallback for older browsers\n                document.querySelectorAll(selector).forEach(img => {\n                    this.loadImage(img);\n                });\n            }\n        },\n\n        loadImage(img) {\n            const src = img.dataset.src;\n            if (src) {\n                img.src = src;\n                img.classList.add(\'loaded\');\n                img.removeAttribute(\'data-src\');\n                \n                // Add loading animation\n                img.style.opacity = \'0\';\n                img.style.transition = \'opacity 0.3s\';\n                \n                img.onload = () => {\n                    img.style.opacity = \'1\';\n                };\n            }\n        },\n\n        refresh() {\n            if (this.observer) {\n                document.querySelectorAll(\'img[data-src]\').forEach(img => {\n                    this.observer.observe(img);\n                });\n            }\n        }\n    },\n\n    // Form validation\n    Validation: {\n        rules: {\n            required: (value) => value.trim() !== \'\',\n            email: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),\n            phone: (value) => /^(\\+998|998)?[0-9]{9}$/.test(value.replace(/[\\s\\-\\(\\)]/g, \'\')),\n            minLength: (value, min) => value.length >= min,\n            maxLength: (value, max) => value.length <= max,\n            numeric: (value) => /^\\d+$/.test(value),\n            alphanumeric: (value) => /^[a-zA-Z0-9]+$/.test(value)\n        },\n\n        messages: {\n            required: \'Bu maydon to\\\'ldirilishi shart\',\n            email: \'Email manzilni to\\\'g\\\'ri kiriting\',\n            phone: \'Telefon raqamni to\\\'g\\\'ri kiriting\',\n            minLength: \'Kamida {min} ta belgi kiriting\',\n            maxLength: \'Ko\\\'pi bilan {max} ta belgi kiriting\',\n            numeric: \'Faqat raqam kiriting\',\n            alphanumeric: \'Faqat harf va raqam kiriting\'\n        },\n\n        validate(form) {\n            const errors = {};\n            const inputs = form.querySelectorAll(\'[data-validation]\');\n\n            inputs.forEach(input => {\n                const rules = input.dataset.validation.split(\'|\');\n                const fieldErrors = [];\n\n                rules.forEach(rule => {\n                    const [ruleName, ...params] = rule.split(\':\');\n                    const ruleFunction = this.rules[ruleName];\n\n                    if (ruleFunction) {\n                        const isValid = ruleFunction(input.value, ...params);\n                        if (!isValid) {\n                            let message = this.messages[ruleName] || \'Xatolik\';\n                            params.forEach((param, index) => {\n                                message = message.replace(`{${Object.keys(params)[index] || index}}`, param);\n                            });\n                            fieldErrors.push(message);\n                        }\n                    }\n                });\n\n                if (fieldErrors.length > 0) {\n                    errors[input.name || input.id] = fieldErrors;\n                    this.showFieldError(input, fieldErrors[0]);\n                } else {\n                    this.clearFieldError(input);\n                }\n            });\n\n            return {\n                isValid: Object.keys(errors).length === 0,\n                errors\n            };\n        },\n\n        showFieldError(input, message) {\n            input.classList.add(\'error\');\n            \n            let errorElement = input.parentNode.querySelector(\'.form-error\');\n            if (!errorElement) {\n                errorElement = document.createElement(\'div\');\n                errorElement.className = \'form-error\';\n                input.parentNode.appendChild(errorElement);\n            }\n            \n            errorElement.textContent = message;\n        },\n\n        clearFieldError(input) {\n            input.classList.remove(\'error\');\n            const errorElement = input.parentNode.querySelector(\'.form-error\');\n            if (errorElement) {\n                errorElement.remove();\n            }\n        },\n\n        clearAllErrors(form) {\n            const inputs = form.querySelectorAll(\'.error\');\n            inputs.forEach(input => this.clearFieldError(input));\n        }\n    },\n\n    // Utility functions\n    Utils: {\n        // Animate element scroll into view\n        scrollIntoView(element, options = {}) {\n            const {\n                behavior = \'smooth\',\n                block = \'center\',\n                inline = \'nearest\',\n                offset = 0\n            } = options;\n\n            if (typeof element === \'string\') {\n                element = document.querySelector(element);\n            }\n\n            if (element) {\n                const elementPosition = element.getBoundingClientRect().top;\n                const offsetPosition = elementPosition + window.pageYOffset - offset;\n\n                window.scrollTo({\n                    top: offsetPosition,\n                    behavior\n                });\n            }\n        },\n\n        // Create and trigger file download\n        downloadFile(data, filename, type = \'application/json\') {\n            const blob = new Blob([data], { type });\n            const url = window.URL.createObjectURL(blob);\n            \n            const link = document.createElement(\'a\');\n            link.href = url;\n            link.download = filename;\n            document.body.appendChild(link);\n            link.click();\n            \n            document.body.removeChild(link);\n            window.URL.revokeObjectURL(url);\n        },\n\n        // Copy text to clipboard with fallback\n        async copyToClipboard(text) {\n            try {\n                await navigator.clipboard.writeText(text);\n                UI.Toast.success(\'Nusxalandi!\');\n                return true;\n            } catch (err) {\n                // Fallback method\n                const textArea = document.createElement(\'textarea\');\n                textArea.value = text;\n                textArea.style.position = \'fixed\';\n                textArea.style.opacity = \'0\';\n                document.body.appendChild(textArea);\n                textArea.focus();\n                textArea.select();\n                \n                try {\n                    document.execCommand(\'copy\');\n                    UI.Toast.success(\'Nusxalandi!\');\n                    return true;\n                } catch (fallbackErr) {\n                    UI.Toast.error(\'Nusxalashda xatolik!\');\n                    return false;\n                } finally {\n                    document.body.removeChild(textArea);\n                }\n            }\n        },\n\n        // Debounced input handler\n        debounceInput(input, callback, delay = 300) {\n            let timeoutId;\n            \n            input.addEventListener(\'input\', (e) => {\n                clearTimeout(timeoutId);\n                timeoutId = setTimeout(() => {\n                    callback(e.target.value, e);\n                }, delay);\n            });\n        },\n\n        // Auto-resize textarea\n        autoResizeTextarea(textarea) {\n            const resize = () => {\n                textarea.style.height = \'auto\';\n                textarea.style.height = textarea.scrollHeight + \'px\';\n            };\n\n            textarea.addEventListener(\'input\', resize);\n            textarea.addEventListener(\'change\', resize);\n            \n            // Initial resize\n            resize();\n        },\n\n        // Format currency input\n        formatCurrencyInput(input) {\n            input.addEventListener(\'input\', (e) => {\n                let value = e.target.value.replace(/[^\\d]/g, \'\');\n                if (value) {\n                    value = parseInt(value).toLocaleString(\'uz-UZ\');\n                }\n                e.target.value = value;\n            });\n        }\n    }\n};\n\n// Initialize UI components when DOM is ready\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n    // Initialize lazy loading\n    UI.LazyLoad.init();\n    \n    // Initialize dropdowns\n    document.querySelectorAll(\'[data-dropdown-trigger]\').forEach(trigger => {\n        const target = trigger.getAttribute(\'data-dropdown-trigger\');\n        const dropdown = document.querySelector(`[data-dropdown=\"${target}\"]`);\n        if (dropdown) {\n            UI.Dropdown.init(`[data-dropdown-trigger=\"${target}\"]`, `[data-dropdown=\"${target}\"]`);\n        }\n    });\n    \n    // Initialize tabs\n    document.querySelectorAll(\'[data-tabs]\').forEach(container => {\n        UI.Tabs.init(`#${container.id}`);\n    });\n    \n    // Initialize accordions\n    document.querySelectorAll(\'[data-accordion]\').forEach(container => {\n        UI.Accordion.init(`#${container.id}`);\n    });\n\n    // Auto-resize textareas\n    document.querySelectorAll(\'textarea[data-auto-resize]\').forEach(textarea => {\n        UI.Utils.autoResizeTextarea(textarea);\n    });\n\n    // Format currency inputs\n    document.querySelectorAll(\'input[data-currency]\').forEach(input => {\n        UI.Utils.formatCurrencyInput(input);\n    });\n});\n\n// Make UI globally available\nwindow.UI = UI;\n